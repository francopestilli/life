<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of feConnectomeBuildModel</title>
  <meta name="keywords" content="feConnectomeBuildModel">
  <meta name="description" content="Compute matrix to predict directional diffusion in each voxel from fibers">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">fe</a> &gt; feConnectomeBuildModel.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for fe&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>feConnectomeBuildModel
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Compute matrix to predict directional diffusion in each voxel from fibers</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function fe = feConnectomeBuildModel(fe) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Compute matrix to predict directional diffusion in each voxel from fibers

   fe = feConnectomeBuildModel(fe)

 INPUTS: fe -  An fe structure, see feCreate.m

 See also: feFitModel.m, feComputePredictedSignal.m

 Example:

 Copyright (2013-2014), Franco Pestilli, Stanford University, pestillifranco@gmail.com.

 -- The LiFE Model --

 LiFE stands for Linear Fascicle Evaluation. The quality of a white-matter
 connectome is evaluated by using the connectome to model the diffusion
 signal in the volume of the connectome.

 The LiFE model is set up in the following way. The diffusion signal in
 the voxels comprising the volume of the connectome is modelled as a
 linear equation of the following form:

   dSig = [M Miso] * w

 Where dSig is a nVoxels * nBvecs x 1 vector containing the predicted
 diffusion signal in each voxel and each diffusion direction measured. M
 is a block matrix that has the following shape:

   M = [fiber_component, isotropic_component]

 Where fiber_component is a nVoxels * nBvecs x nFibers matrix containing
 the contribution of each fiber to the diffusion signal in each voxel and
 direction. This matrix is sparse, because if a fiber does not pass
 through a voxel, the contribution in that combination is set to 0. The
 isotropic_component accounts for the part of the diffusion signal that is
 not generated by the fiber, but rather by other elements of the tissue in
 that voxel and freely diffusing water.

 The fiber_component is the *sum* over contributions from individual unique
 fibers in the voxel. The isotropic_component is simply the mean diffusion
 signal over all directions in the voxel (assumed to be spherical in
 shape...).

 When a fiber passes through a voxel, the element of M at (voxel * bvec, fiber)
 will contain the following the predicted diffusion signal as follows:

   S = S0 exp(-bval*(bvec*Q*bvec))

 Where Q is the quadratic form of the tensor and S0 is the diffusion
 signal measured with no diffusion weighting (baseline measured in B0
 scans).

 M is represented as a Matlab 'sparse' matrix. This saves memory and
 speeds up calculations. However, it makes the computations required in
 building the matrix a little strange.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="feGet.html" class="code" title="function val = feGet(fe,param,varargin)">feGet</a>	Get function for fascicle evaluation structure</li><li><a href="feSet.html" class="code" title="function fe = feSet(fe,param,val,varargin)">feSet</a>	Set fascicle evaluation parameters.</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="feConnectomeInit.html" class="code" title="function fe = feConnectomeInit(dwiFile,fgFileName,feFileName,savedir,dwiFileRepeated,anatomyFile,varargin)">feConnectomeInit</a>	Initialize a new connectome (fe) structure.</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function fe = feConnectomeBuildModel(fe)</a>
0002 <span class="comment">% Compute matrix to predict directional diffusion in each voxel from fibers</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%   fe = feConnectomeBuildModel(fe)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% INPUTS: fe -  An fe structure, see feCreate.m</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% See also: feFitModel.m, feComputePredictedSignal.m</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% Example:</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% Copyright (2013-2014), Franco Pestilli, Stanford University, pestillifranco@gmail.com.</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% -- The LiFE Model --</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% LiFE stands for Linear Fascicle Evaluation. The quality of a white-matter</span>
0017 <span class="comment">% connectome is evaluated by using the connectome to model the diffusion</span>
0018 <span class="comment">% signal in the volume of the connectome.</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% The LiFE model is set up in the following way. The diffusion signal in</span>
0021 <span class="comment">% the voxels comprising the volume of the connectome is modelled as a</span>
0022 <span class="comment">% linear equation of the following form:</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%   dSig = [M Miso] * w</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% Where dSig is a nVoxels * nBvecs x 1 vector containing the predicted</span>
0027 <span class="comment">% diffusion signal in each voxel and each diffusion direction measured. M</span>
0028 <span class="comment">% is a block matrix that has the following shape:</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%   M = [fiber_component, isotropic_component]</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% Where fiber_component is a nVoxels * nBvecs x nFibers matrix containing</span>
0033 <span class="comment">% the contribution of each fiber to the diffusion signal in each voxel and</span>
0034 <span class="comment">% direction. This matrix is sparse, because if a fiber does not pass</span>
0035 <span class="comment">% through a voxel, the contribution in that combination is set to 0. The</span>
0036 <span class="comment">% isotropic_component accounts for the part of the diffusion signal that is</span>
0037 <span class="comment">% not generated by the fiber, but rather by other elements of the tissue in</span>
0038 <span class="comment">% that voxel and freely diffusing water.</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% The fiber_component is the *sum* over contributions from individual unique</span>
0041 <span class="comment">% fibers in the voxel. The isotropic_component is simply the mean diffusion</span>
0042 <span class="comment">% signal over all directions in the voxel (assumed to be spherical in</span>
0043 <span class="comment">% shape...).</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% When a fiber passes through a voxel, the element of M at (voxel * bvec, fiber)</span>
0046 <span class="comment">% will contain the following the predicted diffusion signal as follows:</span>
0047 <span class="comment">%</span>
0048 <span class="comment">%   S = S0 exp(-bval*(bvec*Q*bvec))</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% Where Q is the quadratic form of the tensor and S0 is the diffusion</span>
0051 <span class="comment">% signal measured with no diffusion weighting (baseline measured in B0</span>
0052 <span class="comment">% scans).</span>
0053 <span class="comment">%</span>
0054 <span class="comment">% M is represented as a Matlab 'sparse' matrix. This saves memory and</span>
0055 <span class="comment">% speeds up calculations. However, it makes the computations required in</span>
0056 <span class="comment">% building the matrix a little strange.</span>
0057 
0058 <span class="keyword">if</span> notDefined(<span class="string">'fe'</span>),  error(<span class="string">'LiFE (fe = feCreate) struct needed'</span>); <span class="keyword">end</span>
0059 <span class="keyword">if</span> ~isfield(fe,<span class="string">'life'</span>)
0060   error(<span class="string">'LiFE - the field ''life'' is necessary in the fe structure.'</span>)
0061 <span class="keyword">end</span>
0062 
0063 disp(<span class="string">'LiFE - Building the connectome model...'</span>);
0064 tic
0065 <span class="comment">% Indexes of actually used voxels, this can be less than the number of</span>
0066 <span class="comment">% voxels int he ROI in case some voxels have no fibers in them</span>
0067 usedVoxels   = <a href="feGet.html" class="code" title="function val = feGet(fe,param,varargin)">feGet</a>(fe,<span class="string">'usedVoxels'</span>);
0068 nVoxels      = length(usedVoxels);
0069 nBvecs       = <a href="feGet.html" class="code" title="function val = feGet(fe,param,varargin)">feGet</a>(fe,<span class="string">'nBvecs'</span>);
0070 vox_sparse_pSig = cell(nVoxels,1);
0071 
0072 <span class="comment">% Generate the signal predicted in each voxel by the connectome.</span>
0073 <span class="comment">%</span>
0074 <span class="comment">% This for-loop is written in such a way that matlab (ver later than 7.9)</span>
0075 <span class="comment">% will run it in parallel if parallel processing is allowed.</span>
0076 fprintf(<span class="string">'LiFE - Predicting diffusion signal in %i voxel...\n'</span>,nVoxels);
0077 
0078 feOpenLocalCluster
0079 parfor vv = 1:nVoxels
0080   num_unique_fibers = <a href="feGet.html" class="code" title="function val = feGet(fe,param,varargin)">feGet</a>(fe,<span class="string">'unique f num'</span>,usedVoxels(vv));
0081   
0082   <span class="comment">% This returns a matrix that is size nBvecs x num_unique_fibers</span>
0083   voxelPSignal      = feComputeVoxelSignal(fe,usedVoxels(vv));
0084   
0085   <span class="comment">% Fibers in the connectome determine the directional signal in the voxel</span>
0086   <span class="comment">% signal, not the mean signal in the voxel. Here we first demean the</span>
0087   <span class="comment">% voxel signal we will predict.</span>
0088   <span class="comment">%</span>
0089   <span class="comment">%  demeaned_pSig       = voxelPSignal - repmat(mean(voxelPSignal, 1),nBvecs,1);</span>
0090   <span class="comment">%</span>
0091   <span class="comment">% The mean will be predicted by the Miso part of the matrix, not the</span>
0092   <span class="comment">% Mfiber part.</span>
0093   <span class="comment">%</span>
0094   <span class="comment">% Then we reorganize the demeaned signal into a column vector</span>
0095   <span class="comment">%</span>
0096   <span class="comment">%  vox_sparse_pSig{vv} = reshape(demeaned_pSig', num_unique_fibers * nBvecs, 1) ;</span>
0097   <span class="comment">%</span>
0098   <span class="comment">% Somehow this column vector ends up occupying the right parts of the</span>
0099   <span class="comment">% Mfiber matrix when we are done.  That miracle happens below.</span>
0100   vox_sparse_pSig{vv}   = reshape((voxelPSignal - repmat(mean(voxelPSignal, 1),nBvecs,1))', <span class="keyword">...</span>
0101                           num_unique_fibers * nBvecs, 1) ;
0102 <span class="keyword">end</span>
0103 fprintf(<span class="string">'LiFE - Prediction computed in: %2.3fs.\n'</span>,toc);
0104 
0105 tic
0106 fprintf(<span class="string">'LiFE - Allocating the model prediction...'</span>)
0107 
0108 <span class="comment">% These variables will be used to generate the sparse matrix indices and</span>
0109 <span class="comment">% values (from the dw signal in each voxel-direction). We pre-allocate here</span>
0110 <span class="comment">% for speed. We assign the values in the loop below.  More explanation</span>
0111 <span class="comment">% follows.</span>
0112 
0113 <span class="comment">% Each row and column of the Mfiber matrix represents a unique contribution</span>
0114 <span class="comment">% to the signal in some voxel (group of rows) from a fiber (column).  The</span>
0115 <span class="comment">% total number of elements of Mfiber is the number of unique fibers</span>
0116 <span class="comment">% (columns), times the number of voxels, times the number of directions</span>
0117 <span class="comment">% (rows).</span>
0118 nUniqueFibersInEachVoxel = <a href="feGet.html" class="code" title="function val = feGet(fe,param,varargin)">feGet</a>(fe,<span class="string">'unique f num'</span>);
0119 
0120 <span class="comment">% number of non-zero elements in the MFiber matrix</span>
0121 M_siz  = sum(nUniqueFibersInEachVoxel(1:nVoxels))*nBvecs;
0122 
0123 <span class="comment">% This is a vector that will contain the diffusion signals</span>
0124 M_signal = zeros(M_siz, 1);
0125 
0126 <span class="comment">% These define the row/col entry in the Mfiber matrix where the diffusion</span>
0127 <span class="comment">% signal needs to be stored.</span>
0128 M_rows   = zeros(M_siz, 1);
0129 M_cols   = zeros(M_siz, 1);
0130 
0131 <span class="comment">% Now, pre-allocate space for the measured diffusion signal.  This will be</span>
0132 <span class="comment">% filled up in the following loop, too.</span>
0133 fe       = <a href="feSet.html" class="code" title="function fe = feSet(fe,param,val,varargin)">feSet</a>(fe,<span class="string">'dSig measured'</span>,zeros(1,nVoxels*nBvecs));
0134 
0135 <span class="comment">% The following lines create the *sparse-matrix* indexing into the M matrix.</span>
0136 <span class="comment">% Plus generate a vector of measured signal, full signal and demeaned.</span>
0137 <span class="comment">%</span>
0138 <span class="comment">% The following operations cannot be run in parallel because we address</span>
0139 <span class="comment">% vectors and matrices on the fly.</span>
0140 end_idx = 0;
0141 <span class="keyword">for</span> vv = 1:nVoxels
0142   num_unique_fibers   = <a href="feGet.html" class="code" title="function val = feGet(fe,param,varargin)">feGet</a>(fe,<span class="string">'unique f num'</span>,usedVoxels(vv));
0143   index_unique_fibers = cell2mat(<a href="feGet.html" class="code" title="function val = feGet(fe,param,varargin)">feGet</a>(fe,<span class="string">'unique f'</span>,usedVoxels(vv)));
0144 
0145   <span class="comment">% The first return is a binary vector of the locations of the rows of</span>
0146   <span class="comment">% Mfiber corresponding to the current voxel.  We do the find to get the</span>
0147   <span class="comment">% indices of these rows.</span>
0148   dense_rows  = find(<a href="feGet.html" class="code" title="function val = feGet(fe,param,varargin)">feGet</a>(fe,<span class="string">'voxel rows'</span>,vv));
0149   
0150   <span class="comment">% We determine the column/row combinations for the non-zero elements in</span>
0151   <span class="comment">% the part of M corresponding to the current voxel:</span>
0152   sparse_rows = kron(dense_rows,ones(num_unique_fibers,1));
0153   sparse_cols = repmat(index_unique_fibers, nBvecs, 1);
0154 
0155   <span class="comment">% We need to assign the sparse_* variables into the pre-allocated M_*</span>
0156   <span class="comment">% variables in the right place.</span>
0157   start_idx = end_idx + 1;
0158   end_idx   = end_idx + length(sparse_rows);
0159   
0160   M_rows(start_idx:end_idx)   = sparse_rows;
0161   M_cols(start_idx:end_idx)   = sparse_cols;
0162   M_signal(start_idx:end_idx) = vox_sparse_pSig{vv};
0163   
0164   <span class="comment">% Reorganize the diffusion data for each voxel into a long vector:</span>
0165   <span class="comment">% nDirs X nVoxels.</span>
0166   fe.life.dSig(dense_rows) = <a href="feGet.html" class="code" title="function val = feGet(fe,param,varargin)">feGet</a>(fe,<span class="string">'diffusion signal in voxel'</span>,usedVoxels(vv));
0167 <span class="keyword">end</span>
0168 
0169 <span class="comment">% Install the matrix in the fe structure.</span>
0170 fe = <a href="feSet.html" class="code" title="function fe = feSet(fe,param,val,varargin)">feSet</a>(fe,<span class="string">'Mfiber'</span>,sparse(M_rows, M_cols, M_signal));
0171 
0172 fprintf(<span class="string">'process completed in %2.3fs.\n'</span>,toc)
0173 disp(<span class="string">'LiFE - DONE Building the connectome model.'</span>);
0174 
0175 <span class="keyword">return</span></pre></div>
<hr><address>Generated on Wed 16-Jul-2014 19:56:13 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>